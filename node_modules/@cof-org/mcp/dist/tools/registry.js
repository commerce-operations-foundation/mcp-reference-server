/**
 * Tool Registry
 * Enhanced tool registry with auto-discovery and registration
 */
import * as path from 'path';
import { fileURLToPath } from 'url';
import { Logger } from '../utils/logger.js';
import { registerTools } from './index.js';
// ES module dirname helpers - used by auto-discovery when enabled
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
export class ToolRegistry {
    tools = new Map();
    serviceLayer;
    constructor(serviceLayer) {
        this.serviceLayer = serviceLayer;
        Logger.debug('Tool registry initialized with service layer');
    }
    /**
     * Initialize the registry by auto-discovering and registering tools
     */
    async initialize() {
        this.discoverAndRegisterTools();
        Logger.info(`Tool registry initialized with ${this.tools.size} tools`);
    }
    /**
     * Register a tool
     */
    register(tool) {
        if (this.tools.has(tool.name)) {
            throw new Error(`Tool ${tool.name} is already registered`);
        }
        this.tools.set(tool.name, tool);
        Logger.debug(`Registered tool: ${tool.name}`);
    }
    /**
     * Execute a tool by name
     */
    async execute(name, params) {
        const tool = this.tools.get(name);
        if (!tool) {
            // This should never happen if server checks first, but keep for safety
            throw new Error(`Tool not found: ${name}`);
        }
        Logger.debug(`Executing tool: ${name}`);
        try {
            // Validate input
            const validatedInput = await tool.validateInput(params);
            // Execute tool and return raw result
            // MCP server handles response wrapping automatically
            const result = await tool.execute(validatedInput);
            Logger.debug(`Tool ${name} executed successfully`);
            return result;
        }
        catch (error) {
            Logger.error(`Tool ${name} execution failed:`, error);
            throw error;
        }
    }
    /**
     * List all available tools
     */
    list() {
        return Array.from(this.tools.values()).map((tool) => {
            const desc = tool.getDescription();
            // Ensure inputSchema has type: "object" for SDK compatibility
            return {
                name: desc.name,
                description: desc.description,
                inputSchema: {
                    ...desc.inputSchema,
                    type: 'object',
                },
            };
        });
    }
    /**
     * Check if a tool exists
     */
    has(name) {
        return this.tools.has(name);
    }
    /**
     * Get a tool by name
     */
    get(name) {
        return this.tools.get(name);
    }
    /**
     * Get all tool names
     */
    getToolNames() {
        return Array.from(this.tools.keys());
    }
    /**
     * Get the service orchestrator instance
     */
    getServiceOrchestrator() {
        return this.serviceLayer;
    }
    /**
     * Auto-discover and register all tools from the tools directory
     */
    discoverAndRegisterTools() {
        // Register all tools using the centralized registration functions
        registerTools(this, this.serviceLayer);
        // Auto-discovery capability preserved for future use
        // To enable auto-discovery, uncomment the lines below:
        // const toolsDir = path.join(__dirname);
        // Logger.debug(`Scanning for tools in: ${toolsDir}`);
        // this.scanDirectory(toolsDir);
        void __dirname; // Preserve for auto-discovery
    }
    /**
     * Reload all tools (useful for development/hot-reloading)
     */
    reload() {
        this.tools.clear();
        this.discoverAndRegisterTools();
        Logger.info(`Tool registry reloaded with ${this.tools.size} tools`);
    }
    /**
     * Get tools grouped by category
     */
    getToolsByCategory() {
        const categories = {
            'Fulfillment Management': [],
            'Query Operations': [],
            'Inventory Operations': [],
            Other: [],
        };
        for (const tool of this.tools.values()) {
            const description = tool.getDescription();
            const toolName = tool.name;
            // Ensure inputSchema has type: "object" for SDK compatibility
            const formattedDescription = {
                ...description,
                inputSchema: {
                    ...description.inputSchema,
                    type: 'object',
                },
            };
            if (toolName.includes('order') ||
                toolName.includes('return') ||
                toolName.includes('exchange') ||
                toolName.includes('ship')) {
                categories['Fulfillment Management'].push(formattedDescription);
            }
            else if (toolName.startsWith('get-')) {
                categories['Query Operations'].push(formattedDescription);
            }
            else if (toolName.includes('inventory') || toolName.includes('reserve')) {
                categories['Inventory Operations'].push(formattedDescription);
            }
            else {
                categories['Other'].push(formattedDescription);
            }
        }
        // Remove empty categories
        Object.keys(categories).forEach((key) => {
            if (categories[key].length === 0) {
                delete categories[key];
            }
        });
        return categories;
    }
}
//# sourceMappingURL=registry.js.map