import { MCPError as ProtocolMCPError } from '../errors/index.js';
/**
 * Fulfillment error codes focused on generic categories. Adapter-specific
 * domains should be surfaced through AdapterError instances.
 */
export declare enum FulfillmentErrorCode {
    VALIDATION_ERROR = 2001,
    MISSING_REQUIRED_FIELD = 2002,
    INVALID_FORMAT = 2003,
    RATE_LIMIT_EXCEEDED = 3001,
    TIMEOUT = 3002,
    ADAPTER_ERROR = 4001,
    BACKEND_UNAVAILABLE = 4002,
    NOT_IMPLEMENTED = 5001
}
/**
 * Base Fulfillment error class with support for retryable operations and JSON-RPC conversion.
 * `code` should remain generic so adapter-specific identifiers are carried via data payloads.
 */
export declare class FulfillmentError extends Error {
    code: FulfillmentErrorCode | number;
    retryable: boolean;
    data?: any | undefined;
    readonly isProtocolError: boolean;
    constructor(code: FulfillmentErrorCode | number, message: string, retryable?: boolean, data?: any | undefined);
    /**
     * Convert to MCP JSON-RPC error format
     */
    toJSONRPCError(): ProtocolMCPError;
}
/**
 * Base error class for MCP server errors (for simple cases)
 */
export declare class MCPError extends Error {
    readonly code: string;
    readonly statusCode: number;
    readonly details?: any;
    readonly isProtocolError: boolean;
    readonly retryable: boolean;
    constructor(message: string, code: string, statusCode?: number, details?: any, isProtocolError?: boolean, retryable?: boolean);
}
/**
 * Validation error for schema validation failures
 */
export declare class ValidationError extends FulfillmentError {
    readonly field: string;
    readonly value?: any;
    readonly isProtocolError: boolean;
    constructor(field: string, reason: string, value?: any);
}
/**
 * Backend unavailable error (retryable)
 */
export declare class BackendUnavailableError extends FulfillmentError {
    constructor(backend: string);
}
/**
 * Adapter not initialized error
 */
export declare class AdapterNotInitializedError extends FulfillmentError {
    constructor(message?: string);
}
/**
 * Rate limit exceeded error (retryable)
 */
export declare class RateLimitExceededError extends FulfillmentError {
    constructor(retryAfter?: number);
}
/**
 * Timeout error (retryable)
 */
export declare class TimeoutError extends FulfillmentError {
    constructor(operation: string, timeout: number);
}
/**
 * Not implemented error for features not yet supported
 */
export declare class NotImplementedError extends FulfillmentError {
    constructor(feature: string);
}
/**
 * Configuration error
 */
export declare class ConfigurationError extends MCPError {
    constructor(message: string, details?: any);
}
/**
 * Connection error for adapter connections
 */
export declare class ConnectionError extends MCPError {
    constructor(message: string, details?: any);
}
//# sourceMappingURL=errors.d.ts.map