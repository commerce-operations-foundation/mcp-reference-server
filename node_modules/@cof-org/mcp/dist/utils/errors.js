import { MCPError as ProtocolMCPError } from '../errors/index.js';
/**
 * Fulfillment error codes focused on generic categories. Adapter-specific
 * domains should be surfaced through AdapterError instances.
 */
export var FulfillmentErrorCode;
(function (FulfillmentErrorCode) {
    // Validation errors (2xxx)
    FulfillmentErrorCode[FulfillmentErrorCode["VALIDATION_ERROR"] = 2001] = "VALIDATION_ERROR";
    FulfillmentErrorCode[FulfillmentErrorCode["MISSING_REQUIRED_FIELD"] = 2002] = "MISSING_REQUIRED_FIELD";
    FulfillmentErrorCode[FulfillmentErrorCode["INVALID_FORMAT"] = 2003] = "INVALID_FORMAT";
    // Rate limiting (3xxx)
    FulfillmentErrorCode[FulfillmentErrorCode["RATE_LIMIT_EXCEEDED"] = 3001] = "RATE_LIMIT_EXCEEDED";
    FulfillmentErrorCode[FulfillmentErrorCode["TIMEOUT"] = 3002] = "TIMEOUT";
    // Backend errors (4xxx)
    FulfillmentErrorCode[FulfillmentErrorCode["ADAPTER_ERROR"] = 4001] = "ADAPTER_ERROR";
    FulfillmentErrorCode[FulfillmentErrorCode["BACKEND_UNAVAILABLE"] = 4002] = "BACKEND_UNAVAILABLE";
    // Feature errors (5xxx)
    FulfillmentErrorCode[FulfillmentErrorCode["NOT_IMPLEMENTED"] = 5001] = "NOT_IMPLEMENTED";
})(FulfillmentErrorCode || (FulfillmentErrorCode = {}));
/**
 * Base Fulfillment error class with support for retryable operations and JSON-RPC conversion.
 * `code` should remain generic so adapter-specific identifiers are carried via data payloads.
 */
export class FulfillmentError extends Error {
    code;
    retryable;
    data;
    isProtocolError = false;
    constructor(code, message, retryable = false, data) {
        super(message);
        this.code = code;
        this.retryable = retryable;
        this.data = data;
        this.name = 'FulfillmentError';
        // Ensure proper prototype chain for instanceof checks
        Object.setPrototypeOf(this, FulfillmentError.prototype);
    }
    /**
     * Convert to MCP JSON-RPC error format
     */
    toJSONRPCError() {
        return new ProtocolMCPError(this.code, this.message, {
            retryable: this.retryable,
            isProtocolError: this.isProtocolError,
            ...this.data
        });
    }
}
/**
 * Base error class for MCP server errors (for simple cases)
 */
export class MCPError extends Error {
    code;
    statusCode;
    details;
    isProtocolError = false;
    retryable = false;
    constructor(message, code, statusCode = 500, details, isProtocolError = false, retryable = false) {
        super(message);
        this.name = this.constructor.name;
        this.code = code;
        this.statusCode = statusCode;
        this.details = details;
        this.isProtocolError = isProtocolError;
        this.retryable = retryable;
        // Maintains proper stack trace for where our error was thrown
        Error.captureStackTrace(this, this.constructor);
    }
}
/**
 * Validation error for schema validation failures
 */
export class ValidationError extends FulfillmentError {
    field;
    value;
    isProtocolError = true; // Validation errors are protocol errors
    constructor(field, reason, value) {
        super(FulfillmentErrorCode.VALIDATION_ERROR, `Validation failed for field ${field}: ${reason}`, false, { field, reason, value });
        this.field = field;
        this.value = value;
        Object.setPrototypeOf(this, ValidationError.prototype);
    }
}
/**
 * Backend unavailable error (retryable)
 */
export class BackendUnavailableError extends FulfillmentError {
    constructor(backend) {
        super(FulfillmentErrorCode.BACKEND_UNAVAILABLE, `Backend unavailable: ${backend}`, true, { backend });
        Object.setPrototypeOf(this, BackendUnavailableError.prototype);
    }
}
/**
 * Adapter not initialized error
 */
export class AdapterNotInitializedError extends FulfillmentError {
    constructor(message = 'Adapter not initialized. Call initialize() first.') {
        super(FulfillmentErrorCode.ADAPTER_ERROR, message, false);
        Object.setPrototypeOf(this, AdapterNotInitializedError.prototype);
    }
}
/**
 * Rate limit exceeded error (retryable)
 */
export class RateLimitExceededError extends FulfillmentError {
    constructor(retryAfter) {
        super(FulfillmentErrorCode.RATE_LIMIT_EXCEEDED, `Rate limit exceeded${retryAfter ? `, retry after ${retryAfter}ms` : ''}`, true, { retryAfter });
        Object.setPrototypeOf(this, RateLimitExceededError.prototype);
    }
}
/**
 * Timeout error (retryable)
 */
export class TimeoutError extends FulfillmentError {
    constructor(operation, timeout) {
        super(FulfillmentErrorCode.TIMEOUT, `Operation ${operation} timed out after ${timeout}ms`, true, { operation, timeout });
        Object.setPrototypeOf(this, TimeoutError.prototype);
    }
}
/**
 * Not implemented error for features not yet supported
 */
export class NotImplementedError extends FulfillmentError {
    constructor(feature) {
        super(FulfillmentErrorCode.NOT_IMPLEMENTED, `Feature not implemented: ${feature}`, false, { feature });
        Object.setPrototypeOf(this, NotImplementedError.prototype);
    }
}
/**
 * Configuration error
 */
export class ConfigurationError extends MCPError {
    constructor(message, details) {
        super(`Configuration error: ${message}`, 'CONFIGURATION_ERROR', 500, details);
    }
}
/**
 * Connection error for adapter connections
 */
export class ConnectionError extends MCPError {
    constructor(message, details) {
        super(`Connection error: ${message}`, 'CONNECTION_ERROR', 503, details, false, true);
    }
}
//# sourceMappingURL=errors.js.map