import { FulfillmentError } from './errors.js';
import { Logger } from './logger.js';
/**
 * Retry handler with exponential backoff for operations that may fail temporarily
 */
export class RetryHandler {
    static config = null;
    static defaultOptions = {
        maxRetries: 3,
        initialDelay: 1000,
        maxDelay: 10000,
        backoffMultiplier: 2,
        retryableErrors: (error) => {
            if (error instanceof FulfillmentError) {
                return error.retryable;
            }
            // Also retry on network-related errors
            if (error?.code === 'ECONNRESET' || error?.code === 'ENOTFOUND' || error?.code === 'ETIMEDOUT') {
                return true;
            }
            return false;
        }
    };
    /**
     * Set the retry configuration from server config
     */
    static setConfig(retryConfig) {
        this.config = retryConfig;
    }
    /**
     * Execute an operation with retry logic
     * @param operation - The async operation to execute
     * @param options - Retry configuration options
     * @returns Promise resolving to the operation result
     */
    static async execute(operation, options = {}) {
        // Check if retry is disabled in config
        if (this.config && !this.config.enabled) {
            return operation();
        }
        // Merge config values into options
        const configOptions = {};
        if (this.config) {
            configOptions.maxRetries = this.config.maxAttempts;
            configOptions.initialDelay = this.config.initialDelay;
        }
        const opts = { ...this.defaultOptions, ...configOptions, ...options };
        let lastError;
        let delay = opts.initialDelay;
        const isRetryable = (opts.retryableErrors ?? RetryHandler.defaultOptions.retryableErrors);
        for (let attempt = 0; attempt <= opts.maxRetries; attempt++) {
            try {
                return await operation();
            }
            catch (error) {
                lastError = error;
                // Don't retry on the last attempt or for non-retryable errors
                if (attempt === opts.maxRetries || !isRetryable(error)) {
                    Logger.warn('Operation failed, not retrying', {
                        attempt: attempt + 1,
                        retryable: isRetryable(error),
                        error: error instanceof Error ? error.message : String(error)
                    });
                    throw error;
                }
                Logger.warn(`Operation failed, retrying in ${delay}ms`, {
                    attempt: attempt + 1,
                    maxRetries: opts.maxRetries,
                    delay,
                    error: error instanceof Error ? error.message : String(error)
                });
                await this.sleep(delay);
                // Calculate next delay with exponential backoff
                delay = Math.min(delay * opts.backoffMultiplier, opts.maxDelay);
            }
        }
        // This should never be reached due to the loop logic, but TypeScript requires it
        throw lastError;
    }
    /**
     * Execute multiple operations with retry logic in parallel
     * @param operations - Array of async operations to execute
     * @param options - Retry configuration options
     * @returns Promise resolving to array of operation results
     */
    static async executeAll(operations, options = {}) {
        const promises = operations.map(op => this.execute(op, options));
        return Promise.all(promises);
    }
    /**
     * Execute multiple operations with retry logic, allowing some to fail
     * @param operations - Array of async operations to execute
     * @param options - Retry configuration options
     * @returns Promise resolving to array of settled results
     */
    static async executeAllSettled(operations, options = {}) {
        const promises = operations.map(op => this.execute(op, options));
        return Promise.allSettled(promises);
    }
    /**
     * Sleep for the specified number of milliseconds
     * @param ms - Milliseconds to sleep
     */
    static sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
//# sourceMappingURL=retry.js.map